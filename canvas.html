<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>镂空剪纸效果</title>
    <style>
        body { 
          background-color: red
        }
        #canvas { border: 1px solid #aaaaaa; display: block; margin: 50px auto; }
    </style>
</head>
<body>
<div id="canvas-warp">
    <canvas id="canvas">
        你的浏览器居然不支持Canvas？！赶快换一个吧！！
    </canvas>
</div>

<script>
    window.onload = function(){
        var canvas = document.getElementById("canvas");
        canvas.width = 800;
        canvas.height = 600;
        var context = canvas.getContext("2d");

        context.beginPath();
        context.rect(0,0 ,800,600);
        context.arc(500, 400, 50, 0, Math.PI * 2, true);
        context.closePath();

        context.fillStyle = "rgba(0,0,0,.8)";
        context.fill();

    };

    //逆时针绘制矩形
    function drawPathRect(cxt, x, y, w, h){
        /**
         * 这里不能使用beginPath和closePath，
         * 不然就不属于子路径而是另一个全新的路径，
         * 无法使用非零环绕原则
         */
        cxt.moveTo(x, y);
        cxt.lineTo(x, y + h);
        cxt.lineTo(x + w, y + h);
        cxt.lineTo(x + w, y);
        cxt.lineTo(x, y);

    }

    //逆时针绘制三角形
    function drawPathTriangle(cxt, x1, y1, x2, y2, x3, y3){
        cxt.moveTo(x1,y1);
        cxt.lineTo(x3,y3);
        cxt.lineTo(x2,y2);
        cxt.lineTo(x1,y1);
    }
//     const app = getApp()

// Page({
//   data: {},

//   onLoad: function () {
//     this.position = {
//       x: 150,
//       y: 150,
//       vx: 2,
//       vy: 2
//     }
//     this.x = -100
//     this.radius = 100
//     this.flag = true
//     this.width = 0
//     this.height = 0

//     // 通过 SelectorQuery 获取 Canvas 节点
//     wx.createSelectorQuery()
//       .select('#canvas')
//       .fields({
//         node: true,
//       })
//       .exec(this.init.bind(this))
//   },

//   init(res) {
//     const canvas = res[0].node
//     const ctx = canvas.getContext('2d')
//     this.width = ctx.canvas.width
//     this.height = ctx.canvas.height
//     const renderLoop = () => {
//       this.render(canvas, ctx)
//       canvas.requestAnimationFrame(renderLoop)
//     }
//     canvas.requestAnimationFrame(renderLoop)

//     const img = canvas.createImage()
//     img.onload = () => {
//       this._img = img
//     }
//     img.src = './car.png'
//   },

//   render(canvas, ctx) {
//     ctx.clearRect(0, 0, this.width, this.height)
//     // this.drawBall(ctx)
//     // this.drawCar(ctx)
//     this.drawCricle(ctx)
//   },
//   // 绘制一个圆圈，四周填充半透明灰色
//   drawCricle(cxt) {
//     if (this.flag) {
//       this.radius--
//       if (this.radius<=1) this.flag = false
//     } else {
//       this.radius++
//       if (this.radius > 300) this.flag = true
//     }
//     cxt.beginPath();//开始绘制路径
//     cxt.rect(0, 0, this.width, this.height);
//     let x = this.width/2
//     let y = this.height/2
//     cxt.arc(x,y, this.radius, 0, Math.PI * 2, true);//绘制圆形轨迹
//     cxt.closePath();//结束绘制路径
//     cxt.fillStyle = "rgba(0,0,0,.9)";
//     cxt.fill()
//   },
//   drawBall(ctx) {
//     const p = this.position
//     p.x += p.vx
//     p.y += p.vy
//     if (p.x >= 300) {
//       p.vx = -2
//     }
//     if (p.x <= 7) {
//       p.vx = 2
//     }
//     if (p.y >= 300) {
//       p.vy = -2
//     }
//     if (p.y <= 7) {
//       p.vy = 2
//     }

//     function ball(x, y) {
//       ctx.beginPath()
//       ctx.arc(x, y, 5, 0, Math.PI * 2)
//       ctx.fillStyle = '#1aad19'
//       ctx.strokeStyle = 'rgba(1,1,1,0)'
//       ctx.fill()
//       ctx.stroke()
//     }

//     ball(p.x, 150)
//     ball(150, p.y)
//     ball(300 - p.x, 150)
//     ball(150, 300 - p.y)
//     ball(p.x, p.y)
//     ball(300 - p.x, 300 - p.y)
//     ball(p.x, 300 - p.y)
//     ball(300 - p.x, p.y)
//   },

//   drawCar(ctx) {
//     if (!this._img) return
//     if (this.x > 350) {
//       this.x = -100
//     }
//     ctx.drawImage(this._img, this.x++, 150 - 25, 100, 50)
//     ctx.restore()
//   }
// })


</script>
</body>
</html
