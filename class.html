<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>

</body>
<script type="text/javascript">

  // var s2 = new Child2();
  // s1.play.push(4);
  // console.log(s1.play, s2.play);
// class test {
//   constructor () {
//     this.timestamp = new Date().getTime()
//   }	
// }
// let my = new test()
// console.log(my)
// function Animal(name) {
//   this.name = name; 
// }
// Animal.prototype.eat= function () {
//   console.log(this.name + '正在吃东西')
// };

// function Cat(furColor){ 
//    Animal.call(this,'小花猫');   // 核心代码, 利用call和apply在子类的构造函数中调用父类的构造函数。,这样子类就可以使用父类的属性
//    this.furColor = furColor ;
// };
// let tom = new Cat('black');
// console.log(tom);
// console.log(tom instanceof Animal); // false
// console.log(tom instanceof Cat); // true
// class Animal {
//   constructor(name) {
//     this.name = name; 
//   };
//   eat() {
//     console.log(this.name + '正在吃东西');
//   };
// }

// //.....省略上面Animal类
// class Cat extends Animal {
//   // 子类中一般省略了构造函数，它是默认的，即使我们不添加它也会有
//   constructor(name) {
//     //super作为函数调用时，代表父类的构造函数。
//     super(name);
//   }
//     catchMouse(){
//         console.log(`${this.name}正在捉老鼠`);
//     }
// }
// var cat= new Cat('Tom猫');
// cat.catchMouse();// Tom猫正在捉老鼠

// function test(a,b) {
//   console.log(b)
//   return {
//     test:function(c){
//       return test(c,a);
//     }
//   };
// }

// var retA = test(0);  
// retA.test(2);  
// retA.test(4);  
// retA.test(8);
// var retB = test(0).test(2).test(4).test(8);
// var retC = test('good').test('bad');  
// retC.test('good');  
// retC.test('bad');
// 'use strict'
// var a = function () {
// 	console.log(this) //   输出undefined
// }
// a()
// var c = new a();
// a.prototype.b = 9;
// var b = 7;
// a();

// console.log(b);
// console.log(c.b);

/*策略类*/
// var levelOBJ = {
//     "A": function(money) {
//     	console.log('进入A策略')
//         return money * 4;
//     },
//     "B" : function(money) {
//         return money * 3;
//     },
//     "C" : function(money) {
//         return money * 2;
//     } 
// };
// /*环境类*/
// var calculateBouns =function(level,money) {
//     return levelOBJ[level](money);
// };
// console.log(calculateBouns('A',10000)); // 40000

//原始的飞机类
// var Plane = function () {
// };

// Plane.prototype.fire = function () {
//     console.log('发射普通子弹');
// };


// //装饰类
// var MissileDecorator = function (plane) {
//     this.plane = plane;
// }

// MissileDecorator.prototype.fire = function () {
//     this.plane.fire();
//     console.log('装饰上了新的方法：发射导弹!');
// };

// var plane = new Plane();
// plane = new MissileDecorator(plane);
// plane.fire();

// const Foo = {
//   foo() { console.log('foo') }
// };

// class MyClass {}

// Object.assign(MyClass.prototype, Foo);

// let obj = new MyClass();
// obj.foo() // 'foo'

// var addStrings = function(num1, num2) {
//     let res = ''
//     let carry = 0 // 这是要进的位
//     let i = num1.length - 1
//     let j = num2.length - 1
    
//     // 只要有一方大于0就要继续运算
//     while(i >= 0 || j >= 0) {
//         let n1 = i >= 0 ? num1[i] - '0' : 0 // 这里是为了把单个字母转化为数字
//         let n2 = j >= 0 ? num2[j] - '0' : 0

//         let tmp = n1 + n2 + carry
//         res = (tmp % 10) + res     // 计算剩余的数据
//         carry = tmp >= 10 ? 1 : 0   // 计算进位
//         i--
//         j--
//     }

//     return carry > 0 ? carry + res: res
// }

//  console.log(addStrings('123', '888'))

// let arr = [1,1,3,4,5,6,7,5,4,5,3,2,5,3,4]
// let map = {}
// for (var i = 0; i < arr.length; i++) {
//    map[arr[i]] ?  map[arr[i]] = map[arr[i]] + 1 : map[arr[i]] = 1
// }
// let num = 5
// let count = 0
// for (let i in map) {
//   if (i<5) {
//     count = count + map[i]
//   }
// }
// console.log(count)
function packageMaxValue(weight, value, size){
    // 省略参数合法性校验
    let bagMatrix = []
    // 总重量循环，从重量1开始，计算到重量10，知道了重量9的价值，自然可以计算重量10的价值如何自大
    for(let w = 0; w <= size; w++) {
        // js不能直接创建二维数组，所以在此初始化数组
        bagMatrix[w] = []
        // 循环这五个有价值的物品
        for (let j = 0; j < 5; j++) {
            // 背包的容量为0，那么一个东西也装不下，此时的值肯定也是为0
            if(w === 0) {
                bagMatrix[w][j] = 0
                continue
            }
            // 背包的容量小于物品j的重量，那么就没有上述情况a了
            if(w < weight[j]){
                bagMatrix[w][j] = bagMatrix[w][j-1] || 0
                continue
            }
            //
            bagMatrix[w][j] = Math.max((bagMatrix[w-weight[j]][j-1] || 0) + value[j], bagMatrix[w][j-1] || 0)
        }
    }
    return bagMatrix
}
    
let weight = [4, 5, 6, 2, 2]
let value = [6, 4, 5, 3, 6]
 
console.log(packageMaxValue(weight, value, 10))
</script>
</html>