<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>

</body>
<script type="text/javascript">
// console.log('start')
// let p1 = new Promise((resolve, reject) => {
//   console.log('kk')
//   setTimeout(() => {
//     resolve('zbl')
//   }, 0)
//   console.log('bb')
// }).then((data) => {
//   console.log('result1', data)
//   return 'cc'
// }).then((data) => {
//   console.log('result2', data)
// })
// console.log('end')

// function test(id) {
//   return new Promise(((resolve) => {
//     setTimeout(() => {
//       resolve(id + 'llll')
//     }, 1000)
//   }))
// }
// let p = new Promise(function(resolve, reject){
//     if(true){
//         resolve('123')
//     }else{
//         reject('456')
//     }
// })
// // console.log(p)

// console.log(p)
// let p =new Promise((resolve,reject)=>{
//     resolve(1);
// });

// p.then(data=>{
// 	console.log(data)
//     return 2; //返回一个普通值
// }).then(data=>{
//     console.log(data); //输出2
// });

// 链式调用的目的是为了消去回调地狱的问题，
// 关键是要把多个异步的调用，都封装为promise，在每次then的时候，
// 把上一步的结果，给当前的异步函数传递进去，然后return一个promise到链式中
// new Promise((resolve, reject) => {
//   setTimeout(() => {
//     resolve('zbl')
//   }, 1000)
// }).then((data) => {
//   console.log('result1', data)
//   //dosomething
//   return getUser(data)
//   // setTimeout(() => {
//   //     resolve(data + 'llll')
//   // }, 1000)
// }).then((data) => {
//   console.log('result2', data)
// })
// // test返回一个promise对象
// function getUser(id) {
//   return new Promise(((resolve) => {
//     setTimeout(() => {
//       resolve(id + 'llll')
//     }, 1000)
//   }))
// }

// function isPromise(obj) {
//     return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';  
// }

// const myPromiseAll = (arr)=>{
//     let result = [];
//     return new Promise((resolve,reject)=>{
//         for(let i = 0;i < arr.length;i++){
//             if(isPromise(arr[i])){
//                 arr[i].then((data)=>{
//                     console.log(data)
//                     result[i] = data;
//                     if(result.length === arr.length){
//                         resolve(result)
//                     }
//                 }, function(err) {
//                    result[i] = err;
//                     if(result.length === arr.length){
//                         resolve(result)
//                     }
//                 })
//             }else{
//                 result[i] = arr[i];
//             }
//         }    
//     })
// }

// fetch('https://www.baidu.com',{
//     method: 'GET',
//     mode: 'no-cors',
// })
// .then((response) =>{
//   console.log(response)
// })
// let p1 = new Promise(function(resolve, reject){ 
//         resolve('p1 ok')
//     }); 

// let p2 = new Promise((resolve, reject) => { 
//     console.log('p2')
//     setTimeout(resolve, 2000, 'two'); 
// });
// let p3 = new Promise((resolve, reject) => {
//     console.log('p3')
//     setTimeout(resolve, 3000, 'three');
// });
// let p4 = new Promise((resolve, reject) => {
//     console.log('p4')
//     setTimeout(resolve, 4000, 'four');
// });

// let p5 = new Promise((resolve, reject) => {
//     setTimeout(reject, 4000, 'error');
// });
  
// myPromiseAll([p1, p2, p3, p4]).then(values => { 
//     console.log(values);
// }, reason => {
//     console.log(reason);// reject
// });

    // var p1 = function(){
    //     return new Promise((res, rej) => {
    //         a.b = 'c'
    //         console.log(a)
    //         res('kk')
    //     })
    //     .catch((err) => Promise.reject(err))
    // }
    // p1()
    // async function fun(){
    //     console.log('start')
    //     let cc = await promise1()
    //     console.log(cc)
    //     console.log("1111")

    // }
    // fun()
    // console.log('script start');

    // function dog() {

    //     return new Promise(function(resolve) {
    //         console.log('dog1');
    //         resolve();
    //         console.log("promiseResolve")
    //     }).then(function() {
    //         console.log('dog2');
    //         return "dog"
    //     }).then(console.log("dog end"));
    // }
    // dog()
    // dog()
    // const cat = new Promise(function(resolve) {
    //     console.log('cat1');
    //     resolve();
    //     setTimeout(() => {
    //         console.log('setTimeout1')
    //     })
    // }).then(function() {
    //     console.log('cat2');
    //     return "cat"
    // })

    // setTimeout(function() {
    //     console.log('setTimeout2');
    // }, 0)

    // console.log("before promise.race")

    // Promise.race([dog, cat])
    //     .then((one, two) => {
    //         console.log("one", one)
    //         console.log("two", two)
    //     })
    //     .catch(err => {
    //         console.error('err', err);
    //     })
    
    // console.log('script end');
    
// console.log('start')
// let cat = new Promise(function(resolve) {
//     console.log('cat1');
//     resolve();
//     setTimeout(() => {
//         console.log('setTimeout1')
//     },0)
//     console.log('cat2');
// }).then(function() {
//     console.log('cat2');
// })

// setTimeout(function() {
//     console.log('setTimeout2');
// }, 0)
// console.log('end')

//     function ajax(url){
//         // new一个XHR的对象
//         let xmlhttp = new XMLHttpRequest();
//         let data = {} // 如果是post就有data

//         //判定执行状态
//         xmlhttp.onreadystatechange = function(res){
//            console.log(res)
//         } 
//         xmlhttp.open("Get",url,true);
//         xmlhttp.send(data);    
//     }

// let url = 'https://api.apiopen.top/getSingleJoke?sid=28654780'

// let p1 = new Promise((resolve, reject) => {
//    console.log('p1')
//    setTimeout(() => {
//       console.log('setTimeout end')
//       resolve('zbl')
//    })  
// })

// let p2 = new Promise((resolve, reject) => {
//     console.log('p2')
//     resolve('success')
// })

// Promise.race([p1, p2]).then((result) => {
//   console.log(result)               //['成功了', 'success']
// }).catch((error) => {
//   console.log(error)
// })

// Promise.all([p1,p3,p2]).then((result) => {
//   console.log(result)
// }).catch((error) => {
//   console.log(error)      // 失败了，打出 '失败'
// })

// 
// new Promise(res => {
//     setTimeout(() => {
//         console.log(1)
//         res()
//     })
//     console.log(2)
// })
// console.log(3)

// function a(){
//     return new Promise(res => {
//         console.log(3)
//         res()
//         // setTimeout(() => {
//         //     console.log(4)
//         //     res()
//         // }, 2000)
//     })
// }

// function b(){
//     return new Promise(async res => {
//         console.log(1)
//         res()
//         console.log(2)
//         await a()
//         console.log(5)
//     })
// }

// b().then(() => {
//     console.log(6)
// })


// 1,2,3,5,6,4
// const queue = [1,2,3,4]
// function func(){
//     return new Promise(async res => {
//         await sleep()
//         res(queue[0])
//         if(queue.shift()){
//             return func()
//         }
//     })
// }

// function sleep(){
//     return new Promise(res => {
//         setTimeout(() => res(), 2000)
//     })
// }

// func().then((result) => {
//     console.log('result', result)
// })
// result 1

const arr = [1,2,3,4,5,6]
// arr.map(async (item) => {
//     await sleep(item)
//     console.log('after', item)
// })
function async ss(){
    for (var i = 0; i < arr.length; i++) {
        await sleep(arr[i])
        console.log('after', item)
    }
}

ss()
function sleep(item){
    return new Promise(res => {
        setTimeout(() => {
            res(console.log('before', item))
        }, 2000)
    })
}



</script>
</html>